generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model feedback {
  id                               String             @id
  sessionId                        String
  fromUserId                       String
  toUserId                         String
  rating                           Int
  comment                          String?
  skills                           Json?
  createdAt                        DateTime           @default(now())
  users_feedback_fromUserIdTousers users              @relation("feedback_fromUserIdTousers", fields: [fromUserId], references: [id], onDelete: Cascade)
  interview_sessions               interview_sessions @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  users_feedback_toUserIdTousers   users              @relation("feedback_toUserIdTousers", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([sessionId, fromUserId])
}

model interview_queue {
  id                 String              @id
  userId             String
  profession         String
  preferredDateTime  DateTime
  timeFlexibility    Int                 @default(30)
  status             QueueStatus         @default(WAITING)
  queueType          QueueType
  createdAt          DateTime            @default(now())
  updatedAt          DateTime
  matchedSessionId   String?
  language           String
  interview_sessions interview_sessions? @relation(fields: [matchedSessionId], references: [id])
  users              users               @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model interview_sessions {
  id                                            String            @id
  interviewId                                   String            @unique
  scheduledDateTime                             DateTime
  profession                                    String
  meetingLink                                   String
  status                                        SessionStatus     @default(SCHEDULED)
  candidateId                                   String
  interviewerId                                 String
  createdAt                                     DateTime          @default(now())
  updatedAt                                     DateTime
  language                                      String
  feedback                                      feedback[]
  interview_queue                               interview_queue[]
  users_interview_sessions_candidateIdTousers   users             @relation("interview_sessions_candidateIdTousers", fields: [candidateId], references: [id], onDelete: Cascade)
  interviews                                    interviews        @relation(fields: [interviewId], references: [id], onDelete: Cascade)
  users_interview_sessions_interviewerIdTousers users             @relation("interview_sessions_interviewerIdTousers", fields: [interviewerId], references: [id], onDelete: Cascade)
  notifications                                 notifications[]
}

model interviews {
  id                                    String              @id
  interviewerId                         String
  candidateId                           String
  status                                InterviewStatus     @default(PENDING)
  feedback                              String?
  feedbackReceivedAt                    DateTime?
  createdAt                             DateTime            @default(now())
  updatedAt                             DateTime
  interview_sessions                    interview_sessions?
  users_interviews_candidateIdTousers   users               @relation("interviews_candidateIdTousers", fields: [candidateId], references: [id], onDelete: Cascade)
  users_interviews_interviewerIdTousers users               @relation("interviews_interviewerIdTousers", fields: [interviewerId], references: [id], onDelete: Cascade)
}

model notifications {
  id                 String              @id
  userId             String
  sessionId          String?
  type               NotificationType
  title              String
  message            String
  scheduled          DateTime?
  sent               Boolean             @default(false)
  sentAt             DateTime?
  createdAt          DateTime            @default(now())
  interview_sessions interview_sessions? @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  users              users               @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model selected_professions {
  id         String   @id
  userId     String
  profession String
  createdAt  DateTime @default(now())
  users      users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model user_form_data {
  id         String   @id
  userId     String
  profession String
  country    String
  experience String
  email      String?
  phone      String?
  createdAt  DateTime @default(now())
  language   String
  users      users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model users {
  id                                                         String                 @id
  telegramId                                                 String                 @unique
  username                                                   String?
  firstName                                                  String?
  lastName                                                   String?
  status                                                     UserStatus             @default(INTERVIEWER)
  createdAt                                                  DateTime               @default(now())
  updatedAt                                                  DateTime
  role                                                       UserRole               @default(USER)
  feedback_feedback_fromUserIdTousers                        feedback[]             @relation("feedback_fromUserIdTousers")
  feedback_feedback_toUserIdTousers                          feedback[]             @relation("feedback_toUserIdTousers")
  interview_queue                                            interview_queue[]
  interview_sessions_interview_sessions_candidateIdTousers   interview_sessions[]   @relation("interview_sessions_candidateIdTousers")
  interview_sessions_interview_sessions_interviewerIdTousers interview_sessions[]   @relation("interview_sessions_interviewerIdTousers")
  interviews_interviews_candidateIdTousers                   interviews[]           @relation("interviews_candidateIdTousers")
  interviews_interviews_interviewerIdTousers                 interviews[]           @relation("interviews_interviewerIdTousers")
  notifications                                              notifications[]
  selected_professions                                       selected_professions[]
  user_form_data                                             user_form_data[]
}

enum InterviewStatus {
  PENDING
  COMPLETED
  FEEDBACK_RECEIVED
}

enum NotificationType {
  INTERVIEW_CONFIRMED
  INTERVIEW_REMINDER
  INTERVIEW_CANCELLED
  FEEDBACK_REQUEST
  FEEDBACK_REMINDER
  ROLE_CHANGED
}

enum QueueStatus {
  WAITING
  MATCHED
  CANCELLED
  EXPIRED
}

enum QueueType {
  CANDIDATE
  INTERVIEWER
}

enum SessionStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum UserRole {
  USER
  ADMIN
}

enum UserStatus {
  INTERVIEWER
  CANDIDATE
}
